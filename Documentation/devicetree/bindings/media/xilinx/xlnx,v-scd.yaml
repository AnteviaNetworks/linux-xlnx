# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
%YAML 1.2
---
$id: http://devicetree.org/schemas/media/xilinx/xlnx,v-scd.yaml#
$schema: http://devicetree.org/meta-schemas/core.yaml#

title: Xilinx Scene Change Detection IP.

maintainers:
  - Asif Ikbal <asif.ikbal@amd.com>

description:
  The Xilinx Scene Change Detection IP contains two blocks, one IP block is used
  for reading video frame data from memory to the device and the other IP block
  is used for determining whether there is a scene change between current and the
  previous frame. The IP supports YUV planar and semi-planar formats. IP only
  needs luma frame to determine the scene change event. The IP supports memory
  based model, which means that it will accept a dma buffer address and perform
  MEM2DEV transfer followed by statistical based image processing and give the
  data back to application if scene change detection is present or not.
  Another version of scene change detection IP which supports streaming model,
  which means that IP can be inserted in a capture pipeline. For example,
  "hdmirx -> streaming-scd -> fb_wr" is a typical capture pipeline where
  streaming SCD can be embedded. The IP accespts the AXI video data and perform
  histogram based statistical analysis to detect scene change. The IP supports
  single channel.

properties:
  compatible:
    const: xlnx,v-scd

  reg:
    maxItems: 1

  clocks:
    description: Reference to the AXI Streaming clock.
    maxItems: 1

  interrupts:
    maxItems: 1

  reset-gpios:
    maxItems: 1
    description: Should contain GPIO reset phandle

  xlnx,memorybased:
    description: This is to differentiate between memory based and
      streaming based IP. The value is 1 for memory based
      and 0 for streaming based IPs.
    type: boolean

  xlnx,numstreams:
    description: Number of stream IP connected with SCD.
    $ref: /schemas/types.yaml#/definitions/uint32
    minimum: 1
    maximum: 8

  xlnx,addrwidth:
    description: Size of dma address pointer in IP
    $ref: /schemas/types.yaml#/definitions/uint32
    enum: [32, 64]

  "#address-cells":
    const: 1

  "#size-cells":
    const: 0

  "#dma-cells":
    const: 1
    description: Number of cells in a DMA specifier for consumers.

  ports:
    type: object
    description: Streaming-based device node.

    properties:
      "#address-cells":
        const: 1

      "#size-cells":
        const: 0

    patternProperties:
      "^port@[0-1]$":
        type: object
        description: port@0 is input port. port@1 is output port.

        properties:
          reg:
            enum: [0, 1]

          endpoint:
            type: object

            properties:
              remote-endpoint: true

            required:
              - remote-endpoint

            additionalProperties: false

        required:
          - reg
          - endpoint

        additionalProperties: false

    required:
      - "#address-cells"
      - "#size-cells"
      - port@0
      - port@1

    additionalProperties: false

patternProperties:
  "^subdev@[0-7]$":
    type: object
    description: SCD channel subdevice for memory-based operation.
      Each channel provides an independent V4L2 subdevice interface
      for processing separate video streams.

    properties:
      reg:
        description: Subdevice index (0-7)
        $ref: /schemas/types.yaml#/definitions/uint32
        minimum: 0
        maximum: 7

      "#address-cells":
        const: 1

      "#size-cells":
        const: 0

      port@0:
        type: object
        description: Input port configuration

        properties:
          reg:
            const: 0

          endpoint:
            type: object

            properties:
              remote-endpoint: true

            required:
              - remote-endpoint

            additionalProperties: false

        required:
          - reg
          - endpoint

        additionalProperties: false

    required:
      - "#address-cells"
      - "#size-cells"
      - reg
      - port@0

    additionalProperties: false

required:
  - reg
  - clocks
  - interrupts
  - reset-gpios
  - xlnx,numstreams
  - xlnx,addrwidth

allOf:
  - if:
      required:
        - xlnx,memorybased
    then:
      required:
        - '#dma-cells'

additionalProperties: false

examples:
  - |
    /* Memory-based example (8 streams) */
    v_scenechange: scenechange@a0100000 {
        compatible = "xlnx,v-scd";
        reg = <0xa0100000 0x2000>;
        clocks = <&misc_clk_0>;
        interrupt-parent = <&gic>;
        interrupts = <0 90 4>;
        reset-gpios = <&gpio 94 1>;
        xlnx,memorybased;
        xlnx,numstreams = <8>;
        xlnx,addrwidth = <0x20>;
        #address-cells = <1>;
        #size-cells = <0>;
        #dma-cells = <1>;

        subdev@0 {
          #address-cells = <1>;
          #size-cells = <0>;
          reg = <0>;
          port@0 {
            reg = <0>;
            endpoint {
              remote-endpoint = <&vcap0_out0>;
            };
          };
        };
        subdev@1 {
          #address-cells = <1>;
          #size-cells = <0>;
          reg = <1>;
          port@0 {
            reg = <0>;
            endpoint {
              remote-endpoint = <&vcap0_out1>;
            };
          };
        };
        subdev@2 {
          #address-cells = <1>;
          #size-cells = <0>;
          reg = <2>;
          port@0 {
            reg = <0>;
            endpoint {
              remote-endpoint = <&vcap0_out2>;
            };
          };
        };
        subdev@3 {
          #address-cells = <1>;
          #size-cells = <0>;
          reg = <3>;
          port@0 {
            reg = <0>;
            endpoint {
              remote-endpoint = <&vcap0_out3>;
            };
          };
        };
        subdev@4 {
          #address-cells = <1>;
          #size-cells = <0>;
          reg = <4>;
          port@0 {
            reg = <0>;
            endpoint {
              remote-endpoint = <&vcap0_out4>;
            };
          };
        };
        subdev@5 {
          #address-cells = <1>;
          #size-cells = <0>;
          reg = <5>;
          port@0 {
            reg = <0>;
            endpoint {
              remote-endpoint = <&vcap0_out5>;
            };
          };
        };
        subdev@6 {
          #address-cells = <1>;
          #size-cells = <0>;
          reg = <6>;
          port@0 {
            reg = <0>;
            endpoint {
              remote-endpoint = <&vcap0_out6>;
            };
          };
        };
        subdev@7 {
          #address-cells = <1>;
          #size-cells = <0>;
          reg = <7>;
          port@0 {
            reg = <0>;
            endpoint {
                remote-endpoint = <&vcap0_out7>;
            };
          };
        };
    };

  - |
    /* Streaming-based example (1 stream) */
    v_scenechange_0: scenechange@a0280000 {
        compatible = "xlnx,v-scd";
        reg = <0xa0280000 0x2000>;
        clocks = <&clk 72>;
        interrupt-parent = <&gic>;
        interrupts = <0 111 4>;
        reset-gpios = <&gpio 100 1>;
        xlnx,numstreams = <1>;
        xlnx,addrwidth = <32>;
        #address-cells = <1>;
        #size-cells = <0>;

        ports {
          #address-cells = <1>;
          #size-cells = <0>;
          port@0 {
            reg = <0>;
            scd_in0: endpoint {
              remote-endpoint = <&vpss_scaler_out>;
            };
          };
          port@1 {
            reg = <1>;
            scd_out0: endpoint {
              remote-endpoint = <&vcap_hdmi_in_1>;
            };
          };
        };
    };
